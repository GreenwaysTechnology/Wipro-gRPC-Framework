				gRpc - What is it -RPC Framework
..............................................................................................
				Distributed Application Development
..............................................................................................

There are two design patterns

1.monolithic
   -If you take java application

Domain - ecommerce
 modules - order,payment,product,cart
design application
  -select tech -  java,jee(spring),database -mysql
  -start building app based on domain models
   -high level design,low level desing

-deveploment 
  Application is collection of modules(maven multi module,packages,folders and files)
 each module is collection of classes - objects

Object:
An Object may represent any thing.

An Object may represent called "entity" -  which carries data
An Object represent biz process "service" - which carries biz logic

Since app is collection of objects , each object has to collobrate(communication) with other objects
........................................&&&&&&............................................... 
					Object Relationship
.............................................................................................

1.has-a  -composition  - dependency 
   entity composition - aggreation.
   service composition -  in order to establish object communications
2.is-a
   inheritance - sharing code across multiple classes
.............................................................................................
			        API -Application Programming interface
                                           Procedure 
.............................................................................................
What is api?
  API is the term introduced to represent applications to talk each each other.

What is procedure?
  It is function/method to represent some "biz/system" process

api is modern term to represent procedure.

The term procedure introduced in mainframes , c language.

The api introduced after oo programming languages - c++,java
..............................................................................................
					Procedure call
.............................................................................................

Calling method/function from the another method / function

void calculate(a,b){ 
 int res=add(a,b);
}

int add(a,b){
   //compute
}
...........................................................................................
			 Object Communication -  Procedure calls(method calls)

class OrderService{
   //has-a
   private InventoryService inventory;
  ....
  void placeOrder(){ 
	inventory.updateInventory(payload)
  }
}
class InventoryService{
  void updateInventory(input){

 }
}
..............................................................................................
				
Types of Procedures:

1.local
   
2.remote

runtime/execution env:

if you take java -  jre/jvm

every runtime is process, each process has its own memory address,procee id

if methods are called on single process , we call local object communication.
............................................................................................
				 RPC - API Design Patterns
...........................................................................................

In the beginning, there was industry standard rpc framework - CORBA

The Common Object Request Broker Architecture (CORBA) is a standard defined by the Object Management Group (OMG) that enables software components written in multiple computer languages and running on multiple computers to work together.

DCOM -  Built by microsoft for micro distributed rpc.

..........................................................................................
				Lightweight technology, open source

RMI -  Remote Method Invocation
 written in java, lightweight  uses rmi protocal,but it was not language independant.
 it was not industry ready.


EJB - Written on top of rmi and took idea from corba.

EJB Had lot of drawbacks
............................................................................................. 
 					Internet based RPC - HTTP Driven RPC
.............................................................................................

WebServices:
 It is a remote program, having api , communicated via http protocal , transfer data

SOAP Based:
 it is similar to legacy rpc but communicated over soap over http,transfer xml based data.

REST: 

 It is also RPC but only works with http, carries multiple data format,json was understood
light models


SOA Architectures:
 based on xml distributed programming
..............................................................................................
				Microservices and API Design
.............................................................................................

1.REST API 
   -easy to use/develop
 -what if my app is using multiple languages
    RPC

Drawbacks of REST/HTTP protocal.

REST arch built on the top of "http 1.1" protocal version.


1.multi request-reponse cycle
   in every req-res - tcp connection is created

2.Headers are plain text which takes lot of space
● HTTP is stateless
	○ Headers are sent in every request
	○ Carries info like Cookie
	○ Plain text - relatively large in size
	○ Can not be compressed

3.Serialization & Deserialization
   since http1.1 send always text, not binary which are speedy.


4.API Contract
   There is no api contract (strongly typed) which makes confussion among applications.

5.Client SDK
   There is no proper client sdk to process http messages.
...........................................................................................
					Google and http Protocal
............................................................................................

Google started a project called SPDY (pronounced "speedy") is a deprecated open-specification communication protocol that was developed primarily at Google for transporting web content.[1] SPDY manipulates HTTP traffic

later spdy was opensourced named "HTTP/2"

SPDY became the basis for HTTP/2 specification

Why?
-tcp multiplxing -  non blocking arch
-Binary
-Header Compression
-Flow Control -Streaming
............................................................................................
			RPC - Framework alternate to REST based design
............................................................................................

Google has  started working on RPC systems more than 15 years from now , for service communicaitons.

Project Name 
Stubby
● RPC Framework from Google
● 15 years
● 10 billions reqs / sec!!!!
● Cross-platform
............................................................................................
● Tightly coupled with infrastructure
............................................................................................
				gRPC 

● Developed at Google
● Inspired by Stubby
● Released in 2016
● Adopted by
○ Netflix
○ Microsoft
● Belongs to CNCF
...........................................................................................
				Why gRPC

HTTP2 is default.
○ Binary
○ Multiplexing
○ Flow-control
● Non-blocking, Streaming bindings
● Protobuf
○ Strict Typing
○ DTO
○ Service definitions
○ Language-agnostic
○ Auto-generated bindings for multiple languages
● Great for mobile apps
..............................................................................................
					ProtoBuff-Protocol Buffers
..............................................................................................


● IDL (interface description language) for API
● Platform neutral
● Language neutral
● Serializing/Deserializing structured data
● Very Fast / Optimized for interservices communication
● Provides client libraries automatically for many languages!
○ Java
○ C++
○ Javascript
○ Go
○ Ruby
○ C#
○ Python
............................................................................................
					Steps to Build gRPC- api style services
.............................................................................................

1.Design Api using ProtoBuff language

2.Pick your language for writing services - java
   2.1. write service
   2.2. write servers
   2.3. clients to communicate services via server.
............................................................................................
Lab Req:

1.JDK 11
$ java --version
2.Maven
$ mvn --version
3.docker 

   
setup project
mvn archetype:generate -DgroupId=com.example.grpc  -DartifactId=grpc-gettingstarted-app  -DarchetypeArtifactId=maven-archetype-quickstart  -DinteractiveMode=false


ProtoBuff IDL program:
......................

1.protobuff file has to be saved - serviceName.proto

2.proto is strongly typed , that means we have to specifify the type

3.Field Numbers:
  -which is used by proto interal representation to identify the fields like in REST-Json
is identified by "key": "value" - "id" : 1

 Filed Numbers:
  -which is used by proto interal representation to identify the fields like in REST-Json
is identified by "key": "value"

 each field in the message definition has a unique number.
 These field numbers are used to identify your fields in the message binary format, and should not be changed once your message type is in use. Note that field numbers in the range 1 through 15 take one byte to encode
ncluding the field number and the field's type (you can find out more about this in Protocol Buffer Encoding). Field numbers in the range 16 through 2047 take two bytes. So you should reserve the numbers 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.

The smallest field number you can specify is 1, and the largest is 229 - 1, or 536,870,911


person.proto

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32 age = 2;
}

Convert this protobuff into java.
.....

gRPC team has give compiler called protoc compiler for every operating system and for every language which supports protobuff.

 -https://grpc.io/docs/protoc-installation/

protoc compiler is required to generate code.

But good news, grpc team provides maven plugin for protoc compiler we can use that plugin to generate code via maven /gradle


pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example.grpc</groupId>
    <artifactId>grpc-gettingstarted-app</artifactId>
    <packaging>jar</packaging>
    <version>1.0-SNAPSHOT</version>
    <name>grpc-gettingstarted-app</name>
    <url>http://maven.apache.org</url>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <grpc.version>1.42.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->
        <protobuf.version>3.17.2</protobuf.version>
        <protoc.version>3.17.2</protoc.version>
        <!-- required for jdk9 -->
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty-shaded</artifactId>
            <version>1.41.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>1.41.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>1.41.0</version>
        </dependency>
        <dependency> <!-- necessary for Java 9+ -->
            <groupId>org.apache.tomcat</groupId>
            <artifactId>annotations-api</artifactId>
            <version>6.0.53</version>
            <scope>provided</scope>
        </dependency>

    </dependencies>

    <build>
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.6.2</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.6.1</version>
                <configuration>
                    <protocArtifact>com.google.protobuf:protoc:3.17.3:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.41.0:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>
.............................................................................................

MVN Compile - look at the code has been generated or not.

target/generatedsources/protobuf/java/PersonOuterClass

How to access our entity class , create instance and populate data , print.

In gRPC objects are not created using constructors rather we have to do via "Builder Pattern"/fluent Pattern".

Person person = new Person() ; this wrong

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32 age = 2;
}

package com.example.grpc;

import com.wipro.models.Person;

public class PersonEnityMain {
    public static void main(String[] args) {
      //access Person
        Person person = Person.newBuilder().setName("Subramanian").setAge(40).build();
        System.out.println(person.toString());

    }
}
.....................*********.............................................................
				ProtoBuff Lanaguage				
.............................................................................................

Message Fundamentals
Service Definitions

Testing Two proto generated instance are equals and its hashcode.

package com.example.grpc;

import com.wipro.models.Person;

public class ProtoEqualsTest {
    public static void main(String[] args) {
        Person person1 = Person.newBuilder().setName("Subramanian").setAge(18).build();
        Person person2 = Person.newBuilder().setName("Subramanian").setAge(42).build();
        System.out.println(person1.equals(person2));
        System.out.println(person1.hashCode());
        System.out.println(person2.hashCode());

    }
}
..............................................................................................
				Serialization and Deserialization
..............................................................................................

Serialization:
 Converting object into someformat

Source                                                     Target
________________________________________________________________________
 Object--  seralize it --send over network-------       deseralize---Object

............................................................................ 
                            protocal

RMI 
JVM							    JVM
Source                                                      Target
________________________________________________________________________
 Java Object--  seralize it(binary)---send over network------- deseralize---java Object
............................................................................ 
                             RMI Protocal


Webservices

REST - JSON,XML.....

JVM							    Python
Source                                                      Target
________________________________________________________________________
 Java Object--  seralize it(JSON)---send over network------- deseralize---Python Object
............................................................................ 
				HTTP 1.1


gRPC

JVM							    Python
Source                                                      Target
________________________________________________________________________
  Protobuff-----seralize it into binary------------------deseralize it
............................................................................ 
				HTTP/2

How to seralize and deseralize the protobuff binary into file system?

package com.example.grpc;

import com.wipro.models.Person;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class SeralizationAndDeseralization {
    public static void main(String[] args) {
        Person person = Person.newBuilder().setName("Subramanian").setAge(18).build();
        //File to store the binary.
        Path path = Paths.get("person.ser");
        try {
            Files.write(path, person.toByteArray());
            System.out.println("Serialized");

            //Read Bytes from the disk/network
            byte[] bytes = Files.readAllBytes(path);
            //deseralize the object
            Person parsedPerson = Person.parseFrom(bytes);
            System.out.println("Deserialization done");
            System.out.println(parsedPerson);

        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
.............................................................................................
			   Proto vs Json Performance Testing
............................................................................................
package com.example.grpc;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.protobuf.InvalidProtocolBufferException;
import com.wipro.models.Person;

import java.io.IOException;

public class ProtoBuffVsJsonTesting {
    public static void main(String[] args) {
        //Json Representation
        JPerson jPerson = new JPerson();
        jPerson.setAge(18);
        jPerson.setName("Subramanian");

        Runnable jsonProcessor = () -> {
            //serialization and deserialization
            ObjectMapper objectMapper = new ObjectMapper();
            //serialization
            try {
                byte[] bytes = objectMapper.writeValueAsBytes(jPerson);
                //deserialization
                objectMapper.readValue(bytes, JPerson.class);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
        //proto buff seralization
        Runnable protoProcess = ()->{
            Person person = Person.newBuilder().setName("Subramanian").setAge(18).build();
            byte[] bytes = person.toByteArray();
            try {
                Person person1 = Person.parseFrom(bytes);
            } catch (InvalidProtocolBufferException e) {
                e.printStackTrace();
            }

        };

        for (int i=0;i<5;i++) {
            runPerformanceTest(jsonProcessor, "JSON");
            runPerformanceTest(protoProcess, "PROTO");
        }


    }

    private static void runPerformanceTest(Runnable runnable, String method) {
        long time1 = System.currentTimeMillis();
        for (long i = 0; i < 1_00_000; i++) {
            runnable.run();
        }
        long time2 = System.currentTimeMillis();
        long diff = time2 - time1;
        System.out.println(method + " : " + diff + " ms ");

    }
}
...............................................................................................				Complex Types-Composit Types
..............................................................................................

proto files
//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;

}
package com.example.grpc.types;

import com.wipro.models.Address;
import com.wipro.models.Person;

public class ComplexType {
    public static void main(String[] args) {
        Address address = Address.newBuilder()
                .setState("Tamil Nadu")
                .setStreet("7th Street")
                .setCity("Coimbatore")
                .build();
        Person person = Person.newBuilder()
                .setName("Subramanian")
                .setAge(18)
                .setAddress(address)
                .build();
        System.out.println(person);
    }
}
............................................................................................
				Collecition types - repeated

//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;

}
package com.example.grpc.types;

import com.wipro.models.Address;
import com.wipro.models.Person;

import java.util.Arrays;

public class CollectionMain {
    public static void main(String[] args) {
        Address address = Address.newBuilder()
                .setState("Tamil Nadu")
                .setStreet("7th Street")
                .setCity("Coimbatore")
                .build();
        Person person = Person.newBuilder()
                .setName("Subramanian")
                .setAge(18)
                .setAddress(address)
                .addSkills("Java")
                .addSkills("Javascript")
                .addAllSkills(Arrays.asList("Microservices","gRPC"))
                .build();
        System.out.println(person);
    }
}
.............................................................................................
					Map-Type
............................................................................................

//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;
  map<string,string> values=5;

}
package com.example.grpc.types;

import com.wipro.models.Address;
import com.wipro.models.Person;

import java.util.Arrays;

public class MapMain {
    public static void main(String[] args) {
        Address address = Address.newBuilder()
                .setState("Tamil Nadu")
                .setStreet("7th Street")
                .setCity("Coimbatore")
                .build();
        Person person = Person.newBuilder()
                .setName("Subramanian")
                .setAge(18)
                .setAddress(address)
                .addSkills("Java")
                .addSkills("Javascript")
                .addAllSkills(Arrays.asList("Microservices","gRPC"))
                .putValues("id","1")
                .build();
        System.out.println(person);
    }
}
.............................................................................................
					Enum

//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

enum Feedback {
  UNKNOWN = 0; //default value
  GOOD = 1 ;
  BAD = 2;
  VERYGOOD = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;
  map<string, string> values = 5;
  Feedback feeback = 6;

}
package com.example.grpc.types;

import com.wipro.models.Address;
import com.wipro.models.Feedback;
import com.wipro.models.Person;

import java.util.Arrays;

public class EnumMain {
    public static void main(String[] args) {
        Address address = Address.newBuilder()
                .setState("Tamil Nadu")
                .setStreet("7th Street")
                .setCity("Coimbatore")
                .build();
        Person person = Person.newBuilder()
                .setName("Subramanian")
                .setAge(18)
                .setAddress(address)
                .addSkills("Java")
                .addSkills("Javascript")
                .addAllSkills(Arrays.asList("Microservices","gRPC"))
                .putValues("id","1")
                .setFeeback(Feedback.VERYGOOD)
                .build();
        System.out.println(person  + " " + person.getFeeback());

    }
}
............................................................................................
				 Default Values
............................................................................................
int32 / any number type ->0
bool ->false
string ->empty string
enum ->first value
repeated -> empty list
map ->wrapper / empty map

package com.example.grpc.types;

import com.wipro.models.Person;

public class DefaultValue {
    public static void main(String[] args) {
        Person person=Person.newBuilder().build();
        System.out.println("Age : " + person.getAge());
        System.out.println("FirstName : " + person.getName().trim());
        System.out.println("Feeback : " + person.getFeeback());

    }
}
..............................................................................................
				Proto and Modularity
............................................................................................
			
src/main/proto/common/address.proto


syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}

...................
src/main/proto/person.proto


//proto buff language version ; if dont, default version is 2
syntax = "proto3";

//link other proto files
import "common/address.proto";

//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

/**
message Address {
  string street = 1;
  string city = 2;
  string state = 3;
}
**/
enum Feedback {
  UNKNOWN = 0; //default value
  GOOD = 1 ;
  BAD = 2;
  VERYGOOD = 3;
}

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32  age = 2;
  Address address = 3;
  repeated string skills = 4;
  map<string, string> values = 5;
  Feedback feeback = 6;

}
.............................................................................................
		    Hiding Multiple Implementation under one Type
				Oneof
.............................................................................................	

syntax = "proto3";
option java_multiple_files = true;
option java_package = "com.wipro.models";

message  EmailCredentials {
  string email = 1;
  string password = 2;
}
message  PhoneOTP {
  int32  number = 1;
  int32  code = 2;
}
message  Credentials {
  oneof mode {
    EmailCredentials emailMode = 1;
    PhoneOTP phoneMode = 2;
  }
}
package com.example.grpc.types;

import com.wipro.models.Credentials;
import com.wipro.models.EmailCredentials;
import com.wipro.models.PhoneOTP;

public class OneOfMain {
    public static void main(String[] args) {
        EmailCredentials emailCredentials = EmailCredentials.newBuilder()
                .setEmail("admin@gmail.com")
                .setPassword("admin")
                .build();
        PhoneOTP phoneOTP = PhoneOTP.newBuilder()
                .setNumber(334334234)
                .setCode(200)
                .build();
        Credentials credentials = Credentials.newBuilder()
                .setPhoneMode(phoneOTP)
                .build();
        login(credentials);
        credentials = Credentials.newBuilder()
                .setEmailMode(emailCredentials)
                .build();
        login(credentials);
    }

    private static void login(Credentials credentials) {
        System.out.println(credentials);
        switch (credentials.getModeCase()) {
            case EMAILMODE:
                System.out.println(credentials.getEmailMode().getEmail());
                break;
            case PHONEMODE:
                System.out.println(credentials.getPhoneMode().getNumber());
                break;
        }
    }
}
.............................................................................................
			Wrapper Types-Like Java wrappers -Integer,Double
............................................................................................

syntax = "proto3";
//import wrappers
import "google/protobuf/wrappers.proto";
option java_multiple_files = true;
option java_package = "com.wipro.models";

message Product {
  google.protobuf.Int32Value id = 1;
  google.protobuf.FloatValue price=2;
  string name=3;
}

package com.example.grpc.types;

import com.google.protobuf.FloatValue;
import com.google.protobuf.Int32Value;
import com.wipro.models.Product;

public class WrapperTypes {
    public static void main(String[] args) {
        Product product = Product.newBuilder()
                .setId(Int32Value.newBuilder().setValue(1).build())
                .setPrice(FloatValue.newBuilder().setValue(12.45f).build())
                .setName("Phone")
                .build();
        System.out.println(product);
    }
}
.............................................................................................
				packages

You can add an optional package specifier to a .proto file to prevent name clashes between protocol message types.

src/main/newproduct.proto;

syntax = "proto3";
//import wrappers
package  com.wipro.payment;
option java_multiple_files = true;
//option java_package = "com.wipro.models";

enum PaymentMode {
  UNKNOWN = 0;
  CREDITCARD = 1;
  NETBANKING = 2;
}

Here java_package is optional if you tell , then files to be generated inside option java_package else inside package.

syntax = "proto3";
//import wrappers
import "google/protobuf/wrappers.proto";
import "newproduct.proto";
option java_multiple_files = true;
option java_package = "com.wipro.models";

message Product {
  google.protobuf.Int32Value id = 1;
  google.protobuf.FloatValue price=2;
  string name=3;
  com.wipro.payment.PaymentMode payment=4;
}

package com.example.grpc.types;

import com.google.protobuf.FloatValue;
import com.wipro.models.Product;
import com.wipro.payment.PaymentMode;

public class PackageMain {
    public static void main(String[] args) {
        Product product = Product.newBuilder()
                .setPayment(PaymentMode.NETBANKING)
                .build();
        System.out.println(product);
    }
}

............................................................................................
				Nested Types - looks like inner classes in java

You can define and use message types inside other message types, as in the following example – here the Result message is defined inside the SearchResponse message:

syntax = "proto3";
option java_multiple_files = true;
option java_package = "com.wipro.models";

message SearchResponse {
  message Result {
    string url = 1;
    string title = 2;
  }
  Result results = 1;
}
message SomeOtherMessage {
  SearchResponse.Result result = 1;
}

package com.example.grpc.types;

import com.wipro.models.SearchResponse;

public class NestedTypes {
    public static void main(String[] args) {
        SearchResponse searchResponse = SearchResponse
                .newBuilder()
                .setResults(SearchResponse.Result.newBuilder().setTitle("something").build())
                .build();
        System.out.println(searchResponse);
    }
}

..............................................................................................
				 Services
.............................................................................................

Proto file contains

Message Types

Service Definitions
..............................................................................................
					Service Definitions -like REST Resource
..............................................................................................

Service is Object which defines api, which to be called by other services like normal method calls.

gRPC is based on around the idea of defining  a service, metentioning the methods that can be called remotely with their parameters and return types.

In gRPC provides an IDL (proto Buff) to define service definition and struture of payload.

Types of Payload:
1.Request payload
    -sent by client/consumer service(caller)
2.Response Payload
   - sent by callee service(provider)

gRPC service types:

1.Unary RPC
2.Server Streaming RPC
3.Client Streaming RPC
4.Bidirectional Streaming RPC

Service communication Styles:

1.Synchronous Style
2.Asynchronous Style

Streaming:
.........
 Sending and receiving data in chunks.
..........................................................................................
				Unary Service
............................................................................................

Steps:

1.define proto service definition
//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.service";

//message types
message HelloRequest{
  string name = 1;
  repeated string hobbies = 2;
}
message HelloResponse {
  string greeting = 1;
}
//service definition
service  GreetingService {
  //define rpc operation: Unary: Request-Reply - Fire and Forget -  HTTP - GET
  rpc greeting(HelloRequest) returns (HelloResponse);
}

2. compile the code -  you can see the generated code.


3.Write Service Implementation - provider
package com.wipro.service.greeting;

import com.wipro.service.GreetingServiceGrpc;
import com.wipro.service.HelloRequest;
import com.wipro.service.HelloResponse;
import io.grpc.stub.StreamObserver;

public class GreetingServiceImpl extends GreetingServiceGrpc.GreetingServiceImplBase {
    @Override
    public void greeting(HelloRequest request, StreamObserver<HelloResponse> responseObserver) {
        //Service Biz logic
        String name = request.getName();
        //Response
        HelloResponse response = HelloResponse.newBuilder().setGreeting("Hello " + name).build();
        //writing response into channel
        responseObserver.onNext(response);
        //close the channel or ensure that the response has been committed
        responseObserver.onCompleted();
    }
}

3.Deploy the service on server - We need to create gRPC Server - like Web server


package com.example.grpc.server;

import com.wipro.service.greeting.GreetingServiceImpl;
import io.grpc.Server;
import io.grpc.ServerBuilder;

import java.io.IOException;

public class GRPCServerMain {
    public static void main(String[] args) {
        Server server = ServerBuilder
                .forPort(8080)
                //deploy the service
                .addService(new GreetingServiceImpl())
                .build();
        //start the server
        try {
            server.start();
            System.out.println("gRPC Server is Ready!");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //Keep the main thread alive
        try {
            server.awaitTermination();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
........................................................................................
					Test The Service
..........................................................................................
Client Program :
https://github.com/uw-labs/bloomrpc/releases



package com.example.grpc.client;

import com.wipro.service.GreetingServiceGrpc;
import com.wipro.service.HelloRequest;
import com.wipro.service.HelloResponse;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;

public class GreetingClientApp {
    public static void main(String[] args) {
        //Channel Object
        ManagedChannel channel = ManagedChannelBuilder
                .forTarget("localhost:8080")
                .usePlaintext()// no need of ssl
                .build();
        //Stub Object : Stub is Client Proxy, which is handling all low communication
        GreetingServiceGrpc.GreetingServiceBlockingStub stub = GreetingServiceGrpc.newBlockingStub(channel);
        //Construct Request Payload
        HelloRequest request = HelloRequest.newBuilder().setName("Ram").build();
        //Invoke remote call - RPC and get server response
        HelloResponse helloResponse = stub.greeting(request);
        //log the response
        System.out.println(helloResponse);
        //close the channel
        channel.shutdown();

    }
}
.............................................................................................
					Unary,Streaming
..............................................................................................

Banking App:

-Unary Api
//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.service";

message  BalanceCheckRequest{
  int32 account_number = 1;
}
message Balance {
  int32 amount = 1;
}
//Bank service
service BankService {
  //unary
  rpc getBalance(BalanceCheckRequest) returns (Balance);
}


package com.wipro.service.bank;

import com.wipro.service.Balance;
import com.wipro.service.BalanceCheckRequest;
import com.wipro.service.BankServiceGrpc;
import io.grpc.stub.StreamObserver;

public class BankServiceImpl extends BankServiceGrpc.BankServiceImplBase {
    @Override
    public void getBalance(BalanceCheckRequest request, StreamObserver<Balance> responseObserver) {
        //sending
        int accountNumber = request.getAccountNumber();
        Balance balance = Balance.newBuilder().setAmount(accountNumber * 1000).build();
        responseObserver.onNext(balance);
        responseObserver.onCompleted();
    }
}
.............................................................................................
package com.example.grpc.client;

import com.wipro.service.Balance;
import com.wipro.service.BalanceCheckRequest;
import com.wipro.service.BankServiceGrpc;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;

public class BankUnaryClient {
    public static void main(String[] args) {
        ManagedChannel channel = ManagedChannelBuilder
                .forTarget("localhost:8080")
                .usePlaintext()// no need of ssl
                .build();
        BankServiceGrpc.BankServiceBlockingStub bankServiceBlockingStub = BankServiceGrpc.newBlockingStub(channel);
        BalanceCheckRequest balanceRequest = BalanceCheckRequest.newBuilder().setAccountNumber(8).build();
        Balance balance = bankServiceBlockingStub.getBalance(balanceRequest);
        System.out.println(balance.getAmount());
        //close the channel
        channel.shutdown();
    }
}
.............................................................................................					IN Memory Database
.............................................................................................

package com.example.grpc.util;

import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class AccountDB {
    //generate some account no and its balances
    private final static Map<Integer, Integer> MAP = IntStream
            .rangeClosed(1, 10)
            .boxed()
            .collect(Collectors.toMap(Function.identity(), value -> value * 10));

    public static Integer getBalance(int accountNumber) {
        return MAP.get(accountNumber);
    }

    public static Integer addBalance(int accountNumber, int amount) {
        return MAP.computeIfPresent(accountNumber, (k, v) -> v + amount);
    }

    public static Integer deductBalance(int accountNumber, int amount) {
        return MAP.computeIfPresent(accountNumber, (k, v) -> v - amount);
    }
}


package com.wipro.service.bank;

import com.example.grpc.util.AccountDB;
import com.wipro.service.Balance;
import com.wipro.service.BalanceCheckRequest;
import com.wipro.service.BankServiceGrpc;
import io.grpc.stub.StreamObserver;

public class BankServiceImpl extends BankServiceGrpc.BankServiceImplBase {
    @Override
    public void getBalance(BalanceCheckRequest request, StreamObserver<Balance> responseObserver) {
        //sending
        int accountNumber = request.getAccountNumber();
        //Balance balance = Balance.newBuilder().setAmount(accountNumber * 1000).build();
        Balance balance = Balance.newBuilder().setAmount(AccountDB.getBalance(accountNumber)).build();
        responseObserver.onNext(balance);
        responseObserver.onCompleted();
    }
}



package com.example.grpc.client;

    import com.wipro.service.Balance;
    import com.wipro.service.BalanceCheckRequest;
    import com.wipro.service.BankServiceGrpc;
    import io.grpc.ManagedChannel;
    import io.grpc.ManagedChannelBuilder;

    public class BankUnaryClient {
        public static void main(String[] args) {
            ManagedChannel channel = ManagedChannelBuilder
                    .forTarget("localhost:8080")
                    .usePlaintext()// no need of ssl
                    .build();
            BankServiceGrpc.BankServiceBlockingStub bankServiceBlockingStub = BankServiceGrpc.newBlockingStub(channel);
            BalanceCheckRequest balanceRequest = BalanceCheckRequest.newBuilder().setAccountNumber(10).build();
            Balance balance = bankServiceBlockingStub.getBalance(balanceRequest);
            System.out.println("Balance Received-->" + balance.getAmount());
            //close the channel
            channel.shutdown();
        }
    }

..............................................................................................
				Nodejs Integration.

const grpc = require('grpc')
const protoloader = require('@grpc/proto-loader')

const packageDef = protoloader.loadSync('proto/BankService.proto')
const protoDesc = grpc.loadPackageDefinition(packageDef)

const client = new protoDesc.BankService('localhost:8080', grpc.credentials.createInsecure())

client.getBalance({accountNumber: 2}, (err, balance) => {
    if(err){
        console.error('something bad happened')
    }else{
        console.log('Received : ' + balance.amount)
    }
})

BankService.proto
//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.service";

message  BalanceCheckRequest{
  int32 account_number = 1;
}
message Balance {
  int32 amount = 1;
}
//Bank service
service BankService {
  //unary
  rpc getBalance(BalanceCheckRequest) returns (Balance);
}
.............................................................................................
                                   Server Streaming

Use case : money withdrawal , i want to with draw money 10$ each of total 40$
					
//proto buff language version ; if dont, default version is 2
syntax = "proto3";
//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.service";

message  BalanceCheckRequest{
  int32 account_number = 1;
}
message Balance {
  int32 amount = 1;
}
//WithDrawRequest
message WithDrawRequest {
  int32 account_number = 1;
  int32 amount = 2;
}
//Money to be withdrawn
message Money {
  int32 money = 1;
}
//Bank service
service BankService {
  //unary
  rpc getBalance(BalanceCheckRequest) returns (Balance);
  //server streaming
  rpc withdraw(WithDrawRequest) returns(stream Money);

}
package com.wipro.service.bank;

import com.example.grpc.util.AccountDB;
import com.wipro.service.*;
import io.grpc.stub.StreamObserver;

public class BankServiceImpl extends BankServiceGrpc.BankServiceImplBase {
    @Override
    public void getBalance(BalanceCheckRequest request, StreamObserver<Balance> responseObserver) {
        //sending
        int accountNumber = request.getAccountNumber();
        //Balance balance = Balance.newBuilder().setAmount(accountNumber * 1000).build();
        Balance balance = Balance.newBuilder().setAmount(AccountDB.getBalance(accountNumber)).build();
        responseObserver.onNext(balance);
        responseObserver.onCompleted();
    }
    //with draw logic

    @Override
    public void withdraw(WithDrawRequest request, StreamObserver<Money> responseObserver) {
        int accountNumber = request.getAccountNumber();
        int amount = request.getAmount();
        int balance = AccountDB.getBalance(accountNumber);
        //start sending money in chunks/stream
        for (int i = 0; i < (amount / 10); i++) {
            Money money = Money.newBuilder().setMoney(amount).build();
            //streaming... calling onNext method n- no times
            responseObserver.onNext(money);
            //deduct  money from account
            AccountDB.deductBalance(accountNumber, 10);

            //simulate delay of sending money
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
        //stream completed ; inform that no more data
        responseObserver.onCompleted();
    }
}
..............................................................................................
				 Streaming with Blocking Client Calls
..............................................................................................

package com.example.grpc.client;

import com.wipro.service.BankServiceGrpc;
import com.wipro.service.WithDrawRequest;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;

public class BankingServerStreamingClient {


    public static void main(String[] args) {

        blockingStreaming();

    }

    private static void blockingStreaming() {
        ManagedChannel channel = ManagedChannelBuilder
                .forTarget("localhost:8080")
                .usePlaintext()// no need of ssl
                .build();
        //Stub
        BankServiceGrpc.BankServiceBlockingStub bankServiceBlockingStub = BankServiceGrpc.newBlockingStub(channel);
        WithDrawRequest withdrawRequest = WithDrawRequest.newBuilder().setAccountNumber(7).setAmount(40).build();
        System.out.println("start");
        bankServiceBlockingStub.withdraw(withdrawRequest).forEachRemaining(money -> {
            System.out.println("Received -->" + money.getMoney());
        });

        System.out.println("end");
    }
}
.............................................................................................
..............................................................................................
		   Streaming with Non Blocking/Async Client Calls
..............................................................................................
package com.example.grpc.client;

import com.google.common.util.concurrent.Uninterruptibles;
import com.wipro.service.BankServiceGrpc;
import com.wipro.service.Money;
import com.wipro.service.WithDrawRequest;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;

import java.util.concurrent.TimeUnit;

public class BankingServerStreamingClient {


    public static void main(String[] args) {

        //blockingStreaming();
        asyncStreaming();

    }

    private static void asyncStreaming() {
        ManagedChannel channel = ManagedChannelBuilder
                .forTarget("localhost:8080")
                .usePlaintext()// no need of ssl
                .build();
        //NonBlocking Stub:Async Stub
        BankServiceGrpc.BankServiceStub bankServiceStub = BankServiceGrpc.newStub(channel);

        WithDrawRequest withdrawRequest = WithDrawRequest.newBuilder().setAccountNumber(7).setAmount(40).build();

        System.out.println("Start");
        //Nonblocking results to be emitted into callback interface
        bankServiceStub.withdraw(withdrawRequest, new StreamObserver<Money>() {
            @Override
            public void onNext(Money money) {
                System.out.println("Received-->" + money.getMoney());
            }

            @Override
            public void onError(Throwable throwable) {
                System.out.println(throwable.getMessage());
            }

            @Override
            public void onCompleted() {
                System.out.println("Publisher has completed streaming");
            }
        });

        System.out.println("End");
        Uninterruptibles.sleepUninterruptibly(3, TimeUnit.SECONDS);

    }

    private static void blockingStreaming() {
        ManagedChannel channel = ManagedChannelBuilder
                .forTarget("localhost:8080")
                .usePlaintext()// no need of ssl
                .build();
        //Stub
        BankServiceGrpc.BankServiceBlockingStub bankServiceBlockingStub = BankServiceGrpc.newBlockingStub(channel);
        WithDrawRequest withdrawRequest = WithDrawRequest.newBuilder().setAccountNumber(7).setAmount(40).build();
        System.out.println("start");
        bankServiceBlockingStub.withdraw(withdrawRequest).forEachRemaining(money -> {
            System.out.println("Received -->" + money.getMoney());
        });

        System.out.println("end");
    }
}

