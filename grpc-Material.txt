				gRpc - What is it -RPC Framework
..............................................................................................
				Distributed Application Development
..............................................................................................

There are two design patterns

1.monolithic
   -If you take java application

Domain - ecommerce
 modules - order,payment,product,cart
design application
  -select tech -  java,jee(spring),database -mysql
  -start building app based on domain models
   -high level design,low level desing

-deveploment 
  Application is collection of modules(maven multi module,packages,folders and files)
 each module is collection of classes - objects

Object:
An Object may represent any thing.

An Object may represent called "entity" -  which carries data
An Object represent biz process "service" - which carries biz logic

Since app is collection of objects , each object has to collobrate(communication) with other objects
........................................&&&&&&............................................... 
					Object Relationship
.............................................................................................

1.has-a  -composition  - dependency 
   entity composition - aggreation.
   service composition -  in order to establish object communications
2.is-a
   inheritance - sharing code across multiple classes
.............................................................................................
			        API -Application Programming interface
                                           Procedure 
.............................................................................................
What is api?
  API is the term introduced to represent applications to talk each each other.

What is procedure?
  It is function/method to represent some "biz/system" process

api is modern term to represent procedure.

The term procedure introduced in mainframes , c language.

The api introduced after oo programming languages - c++,java
..............................................................................................
					Procedure call
.............................................................................................

Calling method/function from the another method / function

void calculate(a,b){ 
 int res=add(a,b);
}

int add(a,b){
   //compute
}
...........................................................................................
			 Object Communication -  Procedure calls(method calls)

class OrderService{
   //has-a
   private InventoryService inventory;
  ....
  void placeOrder(){ 
	inventory.updateInventory(payload)
  }
}
class InventoryService{
  void updateInventory(input){

 }
}
..............................................................................................
				
Types of Procedures:

1.local
   
2.remote

runtime/execution env:

if you take java -  jre/jvm

every runtime is process, each process has its own memory address,procee id

if methods are called on single process , we call local object communication.
............................................................................................
				 RPC - API Design Patterns
...........................................................................................

In the beginning, there was industry standard rpc framework - CORBA

The Common Object Request Broker Architecture (CORBA) is a standard defined by the Object Management Group (OMG) that enables software components written in multiple computer languages and running on multiple computers to work together.

DCOM -  Built by microsoft for micro distributed rpc.

..........................................................................................
				Lightweight technology, open source

RMI -  Remote Method Invocation
 written in java, lightweight  uses rmi protocal,but it was not language independant.
 it was not industry ready.


EJB - Written on top of rmi and took idea from corba.

EJB Had lot of drawbacks
............................................................................................. 
 					Internet based RPC - HTTP Driven RPC
.............................................................................................

WebServices:
 It is a remote program, having api , communicated via http protocal , transfer data

SOAP Based:
 it is similar to legacy rpc but communicated over soap over http,transfer xml based data.

REST: 

 It is also RPC but only works with http, carries multiple data format,json was understood
light models


SOA Architectures:
 based on xml distributed programming
..............................................................................................
				Microservices and API Design
.............................................................................................

1.REST API 
   -easy to use/develop
 -what if my app is using multiple languages
    RPC

Drawbacks of REST/HTTP protocal.

REST arch built on the top of "http1.1" protocal version.


1.multi request-reponse cycle
   in every req-res - tcp connection is created

2.Headers are plain text which takes lot of space
● HTTP is stateless
	○ Headers are sent in every request
	○ Carries info like Cookie
	○ Plain text - relatively large in size
	○ Can not be compressed

3.Serialization & Deserialization
   since http1.1 send always text, not binary which are speedy.


4.API Contract
   There is no api contract (strongly typed) which makes confussion among applications.

5.Client SDK
   There is no proper client sdk to process http messages.
...........................................................................................
					Google and http Protocal
............................................................................................

Google started a project called SPDY (pronounced "speedy") is a deprecated open-specification communication protocol that was developed primarily at Google for transporting web content.[1] SPDY manipulates HTTP traffic

later spdy was opensourced named "HTTP/2"

SPDY became the basis for HTTP/2 specification

Why?
-tcp multiplxing -  non blocking arch
-Binary
-Header Compression
-Flow Control -Streaming
............................................................................................
			RPC - Framework alternate to REST based design
............................................................................................

Google has  started working on RPC systems more than 15 years from now , for service communicaitons.

Project Name 
Stubby
● RPC Framework from Google
● 15 years
● 10 billions reqs / sec!!!!
● Cross-platform
............................................................................................
● Tightly coupled with infrastructure
............................................................................................
				gRPC 

● Developed at Google
● Inspired by Stubby
● Released in 2016
● Adopted by
○ Netflix
○ Microsoft
● Belongs to CNCF
...........................................................................................
				Why gRPC

HTTP2 is default.
○ Binary
○ Multiplexing
○ Flow-control
● Non-blocking, Streaming bindings
● Protobuf
○ Strict Typing
○ DTO
○ Service definitions
○ Language-agnostic
○ Auto-generated bindings for multiple languages
● Great for mobile apps
..............................................................................................
					ProtoBuff-Protocol Buffers
..............................................................................................


● IDL (interface description language) for API
● Platform neutral
● Language neutral
● Serializing/Deserializing structured data
● Very Fast / Optimized for interservices communication
● Provides client libraries automatically for many languages!
○ Java
○ C++
○ Javascript
○ Go
○ Ruby
○ C#
○ Python
............................................................................................
					Steps to Build gRPC- api style services
.............................................................................................

1.Design Api using ProtoBuff language

2.Pick your language for writing services - java
   2.1. write service
   2.2. write servers
   2.3. clients to communicate services via server.
............................................................................................
Lab Req:

1.JDK 11
$ java --version
2.Maven
$ mvn --version
3.docker 

   
setup project
mvn archetype:generate -DgroupId=com.example.grpc  -DartifactId=grpc-gettingstarted-app  -DarchetypeArtifactId=maven-archetype-quickstart  -DinteractiveMode=false


ProtoBuff IDL program:
......................

1.protobuff file has to be saved - serviceName.proto

2.proto is strongly typed , that means we have to specifify the type

3.Field Numbers:
  -which is used by proto interal representation to identify the fields like in REST-Json
is identified by "key": "value" - "id" : 1

 Filed Numbers:
  -which is used by proto interal representation to identify the fields like in REST-Json
is identified by "key": "value"

 each field in the message definition has a unique number.
 These field numbers are used to identify your fields in the message binary format, and should not be changed once your message type is in use. Note that field numbers in the range 1 through 15 take one byte to encode
ncluding the field number and the field's type (you can find out more about this in Protocol Buffer Encoding). Field numbers in the range 16 through 2047 take two bytes. So you should reserve the numbers 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.

The smallest field number you can specify is 1, and the largest is 229 - 1, or 536,870,911


person.proto

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32 age = 2;
}

Convert this protobuff into java.
.....

gRPC team has give compiler called protoc compiler for every operating system and for every language which supports protobuff.

 -https://grpc.io/docs/protoc-installation/

protoc compiler is required to generate code.

But good news, grpc team provides maven plugin for protoc compiler we can use that plugin to generate code via maven /gradle


pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example.grpc</groupId>
    <artifactId>grpc-gettingstarted-app</artifactId>
    <packaging>jar</packaging>
    <version>1.0-SNAPSHOT</version>
    <name>grpc-gettingstarted-app</name>
    <url>http://maven.apache.org</url>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <grpc.version>1.42.0-SNAPSHOT</grpc.version><!-- CURRENT_GRPC_VERSION -->
        <protobuf.version>3.17.2</protobuf.version>
        <protoc.version>3.17.2</protoc.version>
        <!-- required for jdk9 -->
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-netty-shaded</artifactId>
            <version>1.41.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-protobuf</artifactId>
            <version>1.41.0</version>
        </dependency>
        <dependency>
            <groupId>io.grpc</groupId>
            <artifactId>grpc-stub</artifactId>
            <version>1.41.0</version>
        </dependency>
        <dependency> <!-- necessary for Java 9+ -->
            <groupId>org.apache.tomcat</groupId>
            <artifactId>annotations-api</artifactId>
            <version>6.0.53</version>
            <scope>provided</scope>
        </dependency>

    </dependencies>

    <build>
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.6.2</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.6.1</version>
                <configuration>
                    <protocArtifact>com.google.protobuf:protoc:3.17.3:exe:${os.detected.classifier}</protocArtifact>
                    <pluginId>grpc-java</pluginId>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.41.0:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>
.............................................................................................

MVN Compile - look at the code has been generated or not.

target/generatedsources/protobuf/java/PersonOuterClass

How to access our entity class , create instance and populate data , print.

In gRPC objects are not created using constructors rather we have to do via "Builder Pattern"/fluent Pattern".

Person person = new Person() ; this wrong

//proto buff language version ; if dont, default version is 2
syntax = "proto3";

//option
option java_multiple_files = true;
//package
option java_package = "com.wipro.models";

//type definition ; in java which is represented as entity class
message Person {
  //fields of the entity
  // string is type
  //name is field(variable)
  //1 is identifier
  string name = 1;
  int32 age = 2;
}

package com.example.grpc;

import com.wipro.models.Person;

public class PersonEnityMain {
    public static void main(String[] args) {
      //access Person
        Person person = Person.newBuilder().setName("Subramanian").setAge(40).build();
        System.out.println(person.toString());

    }
}
.....................*********.............................................................









